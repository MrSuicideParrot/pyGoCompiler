Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    GO
    IMPORT
    DEFER
    PACKAGE
    FALLTHROUGH
    EQUALS
    CASE
    SELECT
    COMMENT
    RETURN
    CHAN
    BREAK
    ELSE
    SWITCH
    FOR
    IF
    MAIN
    STRUCT
    INTERFACE
    SSCAN
    GOTO
    MAP
    STRING
    CONTINUE
    FUNC
    RANGE
    CONST
    VAR
    TYPE
    DEFAULT
    SPRINT

Grammar

Rule 0     S' -> expressionaAR
Rule 1     expressionaAR -> expressionAR PLUS expressionAR
Rule 2     expressionaAR -> expressionAR MINUS expressionAR
Rule 3     expressionaAR -> expressionAR TIMES expressionAR
Rule 4     expressionaAR -> expressionAR DIVIDE expressionAR
Rule 5     expressionAR -> MINUS expressionAR
Rule 6     expressionAR -> INT
Rule 7     expressionAR -> FLOAT
Rule 8     expressionAR -> LPAREN expressionAR RPAREN
Rule 9     expressionAR -> ID
Rule 10    expressionBo -> expressionBo MORE expressionBo
Rule 11    expressionBo -> expressionBo LESS expressionBo
Rule 12    expressionBo -> expressionBo MOREEQUAL expressionBo
Rule 13    expressionBo -> expressionBo LESSEQUAL expressionBo
Rule 14    expressionBo -> expressionBo NOTEQUAL expressionBo
Rule 15    expressionBo -> expressionBo EQUALSTO expressionBo
Rule 16    expressionBo -> TRUE
Rule 17    expressionBo -> FALSE
Rule 18    expressionBo -> LPAREN expressionBo RPAREN
Rule 19    expressionBo -> ID

Terminals, with rules where they appear

BREAK                : 
CASE                 : 
CHAN                 : 
COMMENT              : 
CONST                : 
CONTINUE             : 
DEFAULT              : 
DEFER                : 
DIVIDE               : 4
ELSE                 : 
EQUALS               : 
EQUALSTO             : 15
FALLTHROUGH          : 
FALSE                : 17
FLOAT                : 7
FOR                  : 
FUNC                 : 
GO                   : 
GOTO                 : 
ID                   : 9 19
IF                   : 
IMPORT               : 
INT                  : 6
INTERFACE            : 
LESS                 : 11
LESSEQUAL            : 13
LPAREN               : 8 18
MAIN                 : 
MAP                  : 
MINUS                : 2 5
MORE                 : 10
MOREEQUAL            : 12
NOTEQUAL             : 14
PACKAGE              : 
PLUS                 : 1
RANGE                : 
RETURN               : 
RPAREN               : 8 18
SELECT               : 
SPRINT               : 
SSCAN                : 
STRING               : 
STRUCT               : 
SWITCH               : 
TIMES                : 3
TRUE                 : 16
TYPE                 : 
VAR                  : 
error                : 

Nonterminals, with rules where they appear

expressionAR         : 1 1 2 2 3 3 4 4 5 8
expressionBo         : 10 10 11 11 12 12 13 13 14 14 15 15 18
expressionaAR        : 0

Parsing method: LALR

state 0

    (0) S' -> . expressionaAR
    (1) expressionaAR -> . expressionAR PLUS expressionAR
    (2) expressionaAR -> . expressionAR MINUS expressionAR
    (3) expressionaAR -> . expressionAR TIMES expressionAR
    (4) expressionaAR -> . expressionAR DIVIDE expressionAR
    (5) expressionAR -> . MINUS expressionAR
    (6) expressionAR -> . INT
    (7) expressionAR -> . FLOAT
    (8) expressionAR -> . LPAREN expressionAR RPAREN
    (9) expressionAR -> . ID

    MINUS           shift and go to state 1
    INT             shift and go to state 7
    FLOAT           shift and go to state 4
    LPAREN          shift and go to state 3
    ID              shift and go to state 6

    expressionAR                   shift and go to state 5
    expressionaAR                  shift and go to state 2

state 1

    (5) expressionAR -> MINUS . expressionAR
    (5) expressionAR -> . MINUS expressionAR
    (6) expressionAR -> . INT
    (7) expressionAR -> . FLOAT
    (8) expressionAR -> . LPAREN expressionAR RPAREN
    (9) expressionAR -> . ID

    MINUS           shift and go to state 1
    INT             shift and go to state 7
    FLOAT           shift and go to state 4
    LPAREN          shift and go to state 3
    ID              shift and go to state 6

    expressionAR                   shift and go to state 8

state 2

    (0) S' -> expressionaAR .



state 3

    (8) expressionAR -> LPAREN . expressionAR RPAREN
    (5) expressionAR -> . MINUS expressionAR
    (6) expressionAR -> . INT
    (7) expressionAR -> . FLOAT
    (8) expressionAR -> . LPAREN expressionAR RPAREN
    (9) expressionAR -> . ID

    MINUS           shift and go to state 1
    INT             shift and go to state 7
    FLOAT           shift and go to state 4
    LPAREN          shift and go to state 3
    ID              shift and go to state 6

    expressionAR                   shift and go to state 9

state 4

    (7) expressionAR -> FLOAT .

    RPAREN          reduce using rule 7 (expressionAR -> FLOAT .)
    PLUS            reduce using rule 7 (expressionAR -> FLOAT .)
    MINUS           reduce using rule 7 (expressionAR -> FLOAT .)
    TIMES           reduce using rule 7 (expressionAR -> FLOAT .)
    DIVIDE          reduce using rule 7 (expressionAR -> FLOAT .)
    $end            reduce using rule 7 (expressionAR -> FLOAT .)


state 5

    (1) expressionaAR -> expressionAR . PLUS expressionAR
    (2) expressionaAR -> expressionAR . MINUS expressionAR
    (3) expressionaAR -> expressionAR . TIMES expressionAR
    (4) expressionaAR -> expressionAR . DIVIDE expressionAR

    PLUS            shift and go to state 13
    MINUS           shift and go to state 10
    TIMES           shift and go to state 11
    DIVIDE          shift and go to state 12


state 6

    (9) expressionAR -> ID .

    RPAREN          reduce using rule 9 (expressionAR -> ID .)
    PLUS            reduce using rule 9 (expressionAR -> ID .)
    MINUS           reduce using rule 9 (expressionAR -> ID .)
    TIMES           reduce using rule 9 (expressionAR -> ID .)
    DIVIDE          reduce using rule 9 (expressionAR -> ID .)
    $end            reduce using rule 9 (expressionAR -> ID .)


state 7

    (6) expressionAR -> INT .

    RPAREN          reduce using rule 6 (expressionAR -> INT .)
    PLUS            reduce using rule 6 (expressionAR -> INT .)
    MINUS           reduce using rule 6 (expressionAR -> INT .)
    TIMES           reduce using rule 6 (expressionAR -> INT .)
    DIVIDE          reduce using rule 6 (expressionAR -> INT .)
    $end            reduce using rule 6 (expressionAR -> INT .)


state 8

    (5) expressionAR -> MINUS expressionAR .

    RPAREN          reduce using rule 5 (expressionAR -> MINUS expressionAR .)
    PLUS            reduce using rule 5 (expressionAR -> MINUS expressionAR .)
    MINUS           reduce using rule 5 (expressionAR -> MINUS expressionAR .)
    TIMES           reduce using rule 5 (expressionAR -> MINUS expressionAR .)
    DIVIDE          reduce using rule 5 (expressionAR -> MINUS expressionAR .)
    $end            reduce using rule 5 (expressionAR -> MINUS expressionAR .)


state 9

    (8) expressionAR -> LPAREN expressionAR . RPAREN

    RPAREN          shift and go to state 14


state 10

    (2) expressionaAR -> expressionAR MINUS . expressionAR
    (5) expressionAR -> . MINUS expressionAR
    (6) expressionAR -> . INT
    (7) expressionAR -> . FLOAT
    (8) expressionAR -> . LPAREN expressionAR RPAREN
    (9) expressionAR -> . ID

    MINUS           shift and go to state 1
    INT             shift and go to state 7
    FLOAT           shift and go to state 4
    LPAREN          shift and go to state 3
    ID              shift and go to state 6

    expressionAR                   shift and go to state 15

state 11

    (3) expressionaAR -> expressionAR TIMES . expressionAR
    (5) expressionAR -> . MINUS expressionAR
    (6) expressionAR -> . INT
    (7) expressionAR -> . FLOAT
    (8) expressionAR -> . LPAREN expressionAR RPAREN
    (9) expressionAR -> . ID

    MINUS           shift and go to state 1
    INT             shift and go to state 7
    FLOAT           shift and go to state 4
    LPAREN          shift and go to state 3
    ID              shift and go to state 6

    expressionAR                   shift and go to state 16

state 12

    (4) expressionaAR -> expressionAR DIVIDE . expressionAR
    (5) expressionAR -> . MINUS expressionAR
    (6) expressionAR -> . INT
    (7) expressionAR -> . FLOAT
    (8) expressionAR -> . LPAREN expressionAR RPAREN
    (9) expressionAR -> . ID

    MINUS           shift and go to state 1
    INT             shift and go to state 7
    FLOAT           shift and go to state 4
    LPAREN          shift and go to state 3
    ID              shift and go to state 6

    expressionAR                   shift and go to state 17

state 13

    (1) expressionaAR -> expressionAR PLUS . expressionAR
    (5) expressionAR -> . MINUS expressionAR
    (6) expressionAR -> . INT
    (7) expressionAR -> . FLOAT
    (8) expressionAR -> . LPAREN expressionAR RPAREN
    (9) expressionAR -> . ID

    MINUS           shift and go to state 1
    INT             shift and go to state 7
    FLOAT           shift and go to state 4
    LPAREN          shift and go to state 3
    ID              shift and go to state 6

    expressionAR                   shift and go to state 18

state 14

    (8) expressionAR -> LPAREN expressionAR RPAREN .

    RPAREN          reduce using rule 8 (expressionAR -> LPAREN expressionAR RPAREN .)
    PLUS            reduce using rule 8 (expressionAR -> LPAREN expressionAR RPAREN .)
    MINUS           reduce using rule 8 (expressionAR -> LPAREN expressionAR RPAREN .)
    TIMES           reduce using rule 8 (expressionAR -> LPAREN expressionAR RPAREN .)
    DIVIDE          reduce using rule 8 (expressionAR -> LPAREN expressionAR RPAREN .)
    $end            reduce using rule 8 (expressionAR -> LPAREN expressionAR RPAREN .)


state 15

    (2) expressionaAR -> expressionAR MINUS expressionAR .

    $end            reduce using rule 2 (expressionaAR -> expressionAR MINUS expressionAR .)


state 16

    (3) expressionaAR -> expressionAR TIMES expressionAR .

    $end            reduce using rule 3 (expressionaAR -> expressionAR TIMES expressionAR .)


state 17

    (4) expressionaAR -> expressionAR DIVIDE expressionAR .

    $end            reduce using rule 4 (expressionaAR -> expressionAR DIVIDE expressionAR .)


state 18

    (1) expressionaAR -> expressionAR PLUS expressionAR .

    $end            reduce using rule 1 (expressionaAR -> expressionAR PLUS expressionAR .)

