Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    BREAK
    CASE
    CHAN
    CONST
    CONTINUE
    DEFAULT
    DEFER
    FALLTHROUGH
    GO
    GOTO
    INTERFACE
    MAP
    RANGE
    RETURN
    SELECT
    STRUCT
    SWITCH
    TYPE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
Rule 2     statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET
Rule 3     list -> inst
Rule 4     list -> inst list
Rule 5     assignment -> ID ASSIGN expressionAR
Rule 6     assignment -> ID ASSIGN expressionBo
Rule 7     assignment -> ID EQUALS expressionAR
Rule 8     assignment -> ID EQUALS expressionBo
Rule 9     assignment -> VAR ID EQUALS expressionAR
Rule 10    assignment -> VAR ID EQUALS expressionBo
Rule 11    assignment -> ID INCREMENT
Rule 12    assignment -> ID DECREMENT
Rule 13    inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET
Rule 14    inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
Rule 15    inst -> assignment SEMICOLON
Rule 16    inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
Rule 17    inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET
Rule 18    listID -> expressionAR
Rule 19    listID -> expressionBo
Rule 20    listID -> expressionBo COMMA listID
Rule 21    listID -> expressionAR COMMA listID
Rule 22    IDlist -> ID
Rule 23    IDlist -> ID COMMA IDlist
Rule 24    inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON
Rule 25    inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON
Rule 26    inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON
Rule 27    inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON
Rule 28    expressionAR -> expressionAR PLUS expressionAR
Rule 29    expressionAR -> expressionAR MINUS expressionAR
Rule 30    expressionAR -> expressionAR TIMES expressionAR
Rule 31    expressionAR -> expressionAR DIVIDE expressionAR
Rule 32    expressionAR -> ID
Rule 33    expressionAR -> INT
Rule 34    expressionAR -> MINUS expressionAR
Rule 35    expressionAR -> FLOAT
Rule 36    expressionAR -> LPAREN expressionAR RPAREN
Rule 37    expressionBo -> expressionAR MORE expressionAR
Rule 38    expressionBo -> expressionAR LESS expressionAR
Rule 39    expressionBo -> expressionAR MOREEQUAL expressionAR
Rule 40    expressionBo -> expressionAR LESSEQUAL expressionAR
Rule 41    expressionBo -> expressionBo NOTEQUAL expressionBo
Rule 42    expressionBo -> expressionAR NOTEQUAL expressionAR
Rule 43    expressionBo -> expressionBo EQUALSTO expressionBo
Rule 44    expressionBo -> expressionAR EQUALSTO expressionAR
Rule 45    expressionBo -> expressionBo AND expressionBo
Rule 46    expressionBo -> expressionBo OR expressionBo
Rule 47    expressionBo -> NOT expressionBo
Rule 48    expressionBo -> TRUE
Rule 49    expressionBo -> FALSE
Rule 50    expressionBo -> LPAREN expressionBo RPAREN

Terminals, with rules where they appear

AND                  : 45
ASSIGN               : 5 6
BREAK                : 
CASE                 : 
CHAN                 : 
COMMA                : 20 21 23
COMMENT              : 
CONST                : 
CONTINUE             : 
DECREMENT            : 12
DEFAULT              : 
DEFER                : 
DIVIDE               : 31
ELSE                 : 16
EQUALS               : 7 8 9 10
EQUALSTO             : 43 44
FALLTHROUGH          : 
FALSE                : 49
FLOAT                : 35
FMT                  : 24 25 26 27
FOR                  : 13 14
FUNC                 : 1 2
GO                   : 
GOTO                 : 
ID                   : 5 6 7 8 9 10 11 12 22 23 32
IF                   : 16 17
IMPORT               : 1 2
INCREMENT            : 11
INT                  : 33
INTERFACE            : 
LCURLBRACKET         : 1 2 13 14 16 16 17
LESS                 : 38
LESSEQUAL            : 40
LPAREN               : 1 2 24 25 26 27 36 50
MAIN                 : 1 1 2 2
MAP                  : 
MINUS                : 29 34
MORE                 : 37
MOREEQUAL            : 39
NOT                  : 47
NOTEQUAL             : 41 42
OR                   : 46
PACKAGE              : 1 2
PLUS                 : 28
POINT                : 24 25 26 27
PRINT                : 24 26
RANGE                : 
RCURLBRACKET         : 1 2 13 14 16 16 17
RETURN               : 
RPAREN               : 1 2 24 25 26 27 36 50
SCAN                 : 25 27
SELECT               : 
SEMICOLON            : 14 14 15 24 25 26 27
STRING               : 1 2
STRUCT               : 
SWITCH               : 
TIMES                : 30
TRUE                 : 48
TYPE                 : 
VAR                  : 9 10
error                : 

Nonterminals, with rules where they appear

IDlist               : 23 25
assignment           : 14 14 15
expressionAR         : 5 7 9 18 21 28 28 29 29 30 30 31 31 34 36 37 37 38 38 39 39 40 40 42 42 44 44
expressionBo         : 6 8 10 13 14 16 17 19 20 41 41 43 43 45 45 46 46 47 50
inst                 : 3 4
list                 : 1 4 13 14 16 16 17
listID               : 20 21 24
statement            : 0

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> . PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET

    PACKAGE         shift and go to state 2

    statement                      shift and go to state 1

state 1

    (0) S' -> statement .



state 2

    (1) statement -> PACKAGE . MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE . MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET

    MAIN            shift and go to state 3


state 3

    (1) statement -> PACKAGE MAIN . IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE MAIN . IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET

    IMPORT          shift and go to state 4


state 4

    (1) statement -> PACKAGE MAIN IMPORT . STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE MAIN IMPORT . STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET

    STRING          shift and go to state 5


state 5

    (1) statement -> PACKAGE MAIN IMPORT STRING . FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE MAIN IMPORT STRING . FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET

    FUNC            shift and go to state 6


state 6

    (1) statement -> PACKAGE MAIN IMPORT STRING FUNC . MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE MAIN IMPORT STRING FUNC . MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET

    MAIN            shift and go to state 7


state 7

    (1) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN . LPAREN RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN . LPAREN RPAREN LCURLBRACKET RCURLBRACKET

    LPAREN          shift and go to state 8


state 8

    (1) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN . RPAREN LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN . RPAREN LCURLBRACKET RCURLBRACKET

    RPAREN          shift and go to state 9


state 9

    (1) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN . LCURLBRACKET list RCURLBRACKET
    (2) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN . LCURLBRACKET RCURLBRACKET

    LCURLBRACKET    shift and go to state 10


state 10

    (1) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET . list RCURLBRACKET
    (2) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET . RCURLBRACKET
    (3) list -> . inst
    (4) list -> . inst list
    (13) inst -> . FOR expressionBo LCURLBRACKET list RCURLBRACKET
    (14) inst -> . FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (15) inst -> . assignment SEMICOLON
    (16) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET
    (24) inst -> . FMT POINT PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> . FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> . FMT POINT PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> . FMT POINT SCAN LPAREN RPAREN SEMICOLON
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT

    RCURLBRACKET    shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 16
    FMT             shift and go to state 17
    ID              shift and go to state 18
    VAR             shift and go to state 19

    list                           shift and go to state 11
    inst                           shift and go to state 13
    assignment                     shift and go to state 15

state 11

    (1) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list . RCURLBRACKET

    RCURLBRACKET    shift and go to state 20


state 12

    (2) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET .

    $end            reduce using rule 2 (statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET RCURLBRACKET .)


state 13

    (3) list -> inst .
    (4) list -> inst . list
    (3) list -> . inst
    (4) list -> . inst list
    (13) inst -> . FOR expressionBo LCURLBRACKET list RCURLBRACKET
    (14) inst -> . FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (15) inst -> . assignment SEMICOLON
    (16) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET
    (24) inst -> . FMT POINT PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> . FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> . FMT POINT PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> . FMT POINT SCAN LPAREN RPAREN SEMICOLON
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT

    RCURLBRACKET    reduce using rule 3 (list -> inst .)
    FOR             shift and go to state 14
    IF              shift and go to state 16
    FMT             shift and go to state 17
    ID              shift and go to state 18
    VAR             shift and go to state 19

    inst                           shift and go to state 13
    list                           shift and go to state 21
    assignment                     shift and go to state 15

state 14

    (13) inst -> FOR . expressionBo LCURLBRACKET list RCURLBRACKET
    (14) inst -> FOR . assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 29
    VAR             shift and go to state 19
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 22
    assignment                     shift and go to state 23
    expressionAR                   shift and go to state 24

state 15

    (15) inst -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 33


state 16

    (16) inst -> IF . expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> IF . expressionBo LCURLBRACKET list RCURLBRACKET
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 34
    expressionAR                   shift and go to state 24

state 17

    (24) inst -> FMT . POINT PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> FMT . POINT SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> FMT . POINT PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> FMT . POINT SCAN LPAREN RPAREN SEMICOLON

    POINT           shift and go to state 36


state 18

    (5) assignment -> ID . ASSIGN expressionAR
    (6) assignment -> ID . ASSIGN expressionBo
    (7) assignment -> ID . EQUALS expressionAR
    (8) assignment -> ID . EQUALS expressionBo
    (11) assignment -> ID . INCREMENT
    (12) assignment -> ID . DECREMENT

    ASSIGN          shift and go to state 37
    EQUALS          shift and go to state 38
    INCREMENT       shift and go to state 39
    DECREMENT       shift and go to state 40


state 19

    (9) assignment -> VAR . ID EQUALS expressionAR
    (10) assignment -> VAR . ID EQUALS expressionBo

    ID              shift and go to state 41


state 20

    (1) statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET .

    $end            reduce using rule 1 (statement -> PACKAGE MAIN IMPORT STRING FUNC MAIN LPAREN RPAREN LCURLBRACKET list RCURLBRACKET .)


state 21

    (4) list -> inst list .

    RCURLBRACKET    reduce using rule 4 (list -> inst list .)


state 22

    (13) inst -> FOR expressionBo . LCURLBRACKET list RCURLBRACKET
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    LCURLBRACKET    shift and go to state 42
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 23

    (14) inst -> FOR assignment . SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET

    SEMICOLON       shift and go to state 47


state 24

    (37) expressionBo -> expressionAR . MORE expressionAR
    (38) expressionBo -> expressionAR . LESS expressionAR
    (39) expressionBo -> expressionAR . MOREEQUAL expressionAR
    (40) expressionBo -> expressionAR . LESSEQUAL expressionAR
    (42) expressionBo -> expressionAR . NOTEQUAL expressionAR
    (44) expressionBo -> expressionAR . EQUALSTO expressionAR
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    MORE            shift and go to state 48
    LESS            shift and go to state 49
    MOREEQUAL       shift and go to state 50
    LESSEQUAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUALSTO        shift and go to state 53
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 25

    (47) expressionBo -> NOT . expressionBo
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 58
    expressionAR                   shift and go to state 24

state 26

    (48) expressionBo -> TRUE .

    LCURLBRACKET    reduce using rule 48 (expressionBo -> TRUE .)
    NOTEQUAL        reduce using rule 48 (expressionBo -> TRUE .)
    EQUALSTO        reduce using rule 48 (expressionBo -> TRUE .)
    AND             reduce using rule 48 (expressionBo -> TRUE .)
    OR              reduce using rule 48 (expressionBo -> TRUE .)
    RPAREN          reduce using rule 48 (expressionBo -> TRUE .)
    SEMICOLON       reduce using rule 48 (expressionBo -> TRUE .)
    COMMA           reduce using rule 48 (expressionBo -> TRUE .)


state 27

    (49) expressionBo -> FALSE .

    LCURLBRACKET    reduce using rule 49 (expressionBo -> FALSE .)
    NOTEQUAL        reduce using rule 49 (expressionBo -> FALSE .)
    EQUALSTO        reduce using rule 49 (expressionBo -> FALSE .)
    AND             reduce using rule 49 (expressionBo -> FALSE .)
    OR              reduce using rule 49 (expressionBo -> FALSE .)
    RPAREN          reduce using rule 49 (expressionBo -> FALSE .)
    SEMICOLON       reduce using rule 49 (expressionBo -> FALSE .)
    COMMA           reduce using rule 49 (expressionBo -> FALSE .)


state 28

    (50) expressionBo -> LPAREN . expressionBo RPAREN
    (36) expressionAR -> LPAREN . expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 59
    expressionAR                   shift and go to state 60

state 29

    (5) assignment -> ID . ASSIGN expressionAR
    (6) assignment -> ID . ASSIGN expressionBo
    (7) assignment -> ID . EQUALS expressionAR
    (8) assignment -> ID . EQUALS expressionBo
    (11) assignment -> ID . INCREMENT
    (12) assignment -> ID . DECREMENT
    (32) expressionAR -> ID .

    ASSIGN          shift and go to state 37
    EQUALS          shift and go to state 38
    INCREMENT       shift and go to state 39
    DECREMENT       shift and go to state 40
    MORE            reduce using rule 32 (expressionAR -> ID .)
    LESS            reduce using rule 32 (expressionAR -> ID .)
    MOREEQUAL       reduce using rule 32 (expressionAR -> ID .)
    LESSEQUAL       reduce using rule 32 (expressionAR -> ID .)
    NOTEQUAL        reduce using rule 32 (expressionAR -> ID .)
    EQUALSTO        reduce using rule 32 (expressionAR -> ID .)
    PLUS            reduce using rule 32 (expressionAR -> ID .)
    MINUS           reduce using rule 32 (expressionAR -> ID .)
    TIMES           reduce using rule 32 (expressionAR -> ID .)
    DIVIDE          reduce using rule 32 (expressionAR -> ID .)


state 30

    (34) expressionAR -> MINUS . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 61

state 31

    (33) expressionAR -> INT .

    MORE            reduce using rule 33 (expressionAR -> INT .)
    LESS            reduce using rule 33 (expressionAR -> INT .)
    MOREEQUAL       reduce using rule 33 (expressionAR -> INT .)
    LESSEQUAL       reduce using rule 33 (expressionAR -> INT .)
    NOTEQUAL        reduce using rule 33 (expressionAR -> INT .)
    EQUALSTO        reduce using rule 33 (expressionAR -> INT .)
    PLUS            reduce using rule 33 (expressionAR -> INT .)
    MINUS           reduce using rule 33 (expressionAR -> INT .)
    TIMES           reduce using rule 33 (expressionAR -> INT .)
    DIVIDE          reduce using rule 33 (expressionAR -> INT .)
    RPAREN          reduce using rule 33 (expressionAR -> INT .)
    SEMICOLON       reduce using rule 33 (expressionAR -> INT .)
    LCURLBRACKET    reduce using rule 33 (expressionAR -> INT .)
    AND             reduce using rule 33 (expressionAR -> INT .)
    OR              reduce using rule 33 (expressionAR -> INT .)
    COMMA           reduce using rule 33 (expressionAR -> INT .)


state 32

    (35) expressionAR -> FLOAT .

    MORE            reduce using rule 35 (expressionAR -> FLOAT .)
    LESS            reduce using rule 35 (expressionAR -> FLOAT .)
    MOREEQUAL       reduce using rule 35 (expressionAR -> FLOAT .)
    LESSEQUAL       reduce using rule 35 (expressionAR -> FLOAT .)
    NOTEQUAL        reduce using rule 35 (expressionAR -> FLOAT .)
    EQUALSTO        reduce using rule 35 (expressionAR -> FLOAT .)
    PLUS            reduce using rule 35 (expressionAR -> FLOAT .)
    MINUS           reduce using rule 35 (expressionAR -> FLOAT .)
    TIMES           reduce using rule 35 (expressionAR -> FLOAT .)
    DIVIDE          reduce using rule 35 (expressionAR -> FLOAT .)
    RPAREN          reduce using rule 35 (expressionAR -> FLOAT .)
    SEMICOLON       reduce using rule 35 (expressionAR -> FLOAT .)
    LCURLBRACKET    reduce using rule 35 (expressionAR -> FLOAT .)
    AND             reduce using rule 35 (expressionAR -> FLOAT .)
    OR              reduce using rule 35 (expressionAR -> FLOAT .)
    COMMA           reduce using rule 35 (expressionAR -> FLOAT .)


state 33

    (15) inst -> assignment SEMICOLON .

    FOR             reduce using rule 15 (inst -> assignment SEMICOLON .)
    IF              reduce using rule 15 (inst -> assignment SEMICOLON .)
    FMT             reduce using rule 15 (inst -> assignment SEMICOLON .)
    ID              reduce using rule 15 (inst -> assignment SEMICOLON .)
    VAR             reduce using rule 15 (inst -> assignment SEMICOLON .)
    RCURLBRACKET    reduce using rule 15 (inst -> assignment SEMICOLON .)


state 34

    (16) inst -> IF expressionBo . LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> IF expressionBo . LCURLBRACKET list RCURLBRACKET
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    LCURLBRACKET    shift and go to state 63
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 35

    (32) expressionAR -> ID .

    MORE            reduce using rule 32 (expressionAR -> ID .)
    LESS            reduce using rule 32 (expressionAR -> ID .)
    MOREEQUAL       reduce using rule 32 (expressionAR -> ID .)
    LESSEQUAL       reduce using rule 32 (expressionAR -> ID .)
    NOTEQUAL        reduce using rule 32 (expressionAR -> ID .)
    EQUALSTO        reduce using rule 32 (expressionAR -> ID .)
    PLUS            reduce using rule 32 (expressionAR -> ID .)
    MINUS           reduce using rule 32 (expressionAR -> ID .)
    TIMES           reduce using rule 32 (expressionAR -> ID .)
    DIVIDE          reduce using rule 32 (expressionAR -> ID .)
    RPAREN          reduce using rule 32 (expressionAR -> ID .)
    SEMICOLON       reduce using rule 32 (expressionAR -> ID .)
    LCURLBRACKET    reduce using rule 32 (expressionAR -> ID .)
    AND             reduce using rule 32 (expressionAR -> ID .)
    OR              reduce using rule 32 (expressionAR -> ID .)
    COMMA           reduce using rule 32 (expressionAR -> ID .)


state 36

    (24) inst -> FMT POINT . PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> FMT POINT . SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> FMT POINT . PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> FMT POINT . SCAN LPAREN RPAREN SEMICOLON

    PRINT           shift and go to state 64
    SCAN            shift and go to state 65


state 37

    (5) assignment -> ID ASSIGN . expressionAR
    (6) assignment -> ID ASSIGN . expressionBo
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 68
    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27

    expressionAR                   shift and go to state 66
    expressionBo                   shift and go to state 67

state 38

    (7) assignment -> ID EQUALS . expressionAR
    (8) assignment -> ID EQUALS . expressionBo
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 68
    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27

    expressionAR                   shift and go to state 69
    expressionBo                   shift and go to state 70

state 39

    (11) assignment -> ID INCREMENT .

    SEMICOLON       reduce using rule 11 (assignment -> ID INCREMENT .)
    LCURLBRACKET    reduce using rule 11 (assignment -> ID INCREMENT .)


state 40

    (12) assignment -> ID DECREMENT .

    SEMICOLON       reduce using rule 12 (assignment -> ID DECREMENT .)
    LCURLBRACKET    reduce using rule 12 (assignment -> ID DECREMENT .)


state 41

    (9) assignment -> VAR ID . EQUALS expressionAR
    (10) assignment -> VAR ID . EQUALS expressionBo

    EQUALS          shift and go to state 71


state 42

    (13) inst -> FOR expressionBo LCURLBRACKET . list RCURLBRACKET
    (3) list -> . inst
    (4) list -> . inst list
    (13) inst -> . FOR expressionBo LCURLBRACKET list RCURLBRACKET
    (14) inst -> . FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (15) inst -> . assignment SEMICOLON
    (16) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET
    (24) inst -> . FMT POINT PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> . FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> . FMT POINT PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> . FMT POINT SCAN LPAREN RPAREN SEMICOLON
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT

    FOR             shift and go to state 14
    IF              shift and go to state 16
    FMT             shift and go to state 17
    ID              shift and go to state 18
    VAR             shift and go to state 19

    list                           shift and go to state 72
    inst                           shift and go to state 13
    assignment                     shift and go to state 15

state 43

    (41) expressionBo -> expressionBo NOTEQUAL . expressionBo
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 73
    expressionAR                   shift and go to state 24

state 44

    (43) expressionBo -> expressionBo EQUALSTO . expressionBo
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 74
    expressionAR                   shift and go to state 24

state 45

    (45) expressionBo -> expressionBo AND . expressionBo
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 75
    expressionAR                   shift and go to state 24

state 46

    (46) expressionBo -> expressionBo OR . expressionBo
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 76
    expressionAR                   shift and go to state 24

state 47

    (14) inst -> FOR assignment SEMICOLON . expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    LPAREN          shift and go to state 28
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32

    expressionBo                   shift and go to state 77
    expressionAR                   shift and go to state 24

state 48

    (37) expressionBo -> expressionAR MORE . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 78

state 49

    (38) expressionBo -> expressionAR LESS . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 79

state 50

    (39) expressionBo -> expressionAR MOREEQUAL . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 80

state 51

    (40) expressionBo -> expressionAR LESSEQUAL . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 81

state 52

    (42) expressionBo -> expressionAR NOTEQUAL . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 82

state 53

    (44) expressionBo -> expressionAR EQUALSTO . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 83

state 54

    (28) expressionAR -> expressionAR PLUS . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 84

state 55

    (29) expressionAR -> expressionAR MINUS . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 85

state 56

    (30) expressionAR -> expressionAR TIMES . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 86

state 57

    (31) expressionAR -> expressionAR DIVIDE . expressionAR
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 87

state 58

    (47) expressionBo -> NOT expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    LCURLBRACKET    reduce using rule 47 (expressionBo -> NOT expressionBo .)
    NOTEQUAL        reduce using rule 47 (expressionBo -> NOT expressionBo .)
    EQUALSTO        reduce using rule 47 (expressionBo -> NOT expressionBo .)
    AND             reduce using rule 47 (expressionBo -> NOT expressionBo .)
    OR              reduce using rule 47 (expressionBo -> NOT expressionBo .)
    RPAREN          reduce using rule 47 (expressionBo -> NOT expressionBo .)
    SEMICOLON       reduce using rule 47 (expressionBo -> NOT expressionBo .)
    COMMA           reduce using rule 47 (expressionBo -> NOT expressionBo .)

  ! NOTEQUAL        [ shift and go to state 43 ]
  ! EQUALSTO        [ shift and go to state 44 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]


state 59

    (50) expressionBo -> LPAREN expressionBo . RPAREN
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    RPAREN          shift and go to state 88
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 60

    (36) expressionAR -> LPAREN expressionAR . RPAREN
    (37) expressionBo -> expressionAR . MORE expressionAR
    (38) expressionBo -> expressionAR . LESS expressionAR
    (39) expressionBo -> expressionAR . MOREEQUAL expressionAR
    (40) expressionBo -> expressionAR . LESSEQUAL expressionAR
    (42) expressionBo -> expressionAR . NOTEQUAL expressionAR
    (44) expressionBo -> expressionAR . EQUALSTO expressionAR
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    RPAREN          shift and go to state 89
    MORE            shift and go to state 48
    LESS            shift and go to state 49
    MOREEQUAL       shift and go to state 50
    LESSEQUAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUALSTO        shift and go to state 53
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 61

    (34) expressionAR -> MINUS expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    MORE            reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    LESS            reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    MOREEQUAL       reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    LESSEQUAL       reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    NOTEQUAL        reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    EQUALSTO        reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    PLUS            reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    MINUS           reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    TIMES           reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    DIVIDE          reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    RPAREN          reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    SEMICOLON       reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    LCURLBRACKET    reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    AND             reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    OR              reduce using rule 34 (expressionAR -> MINUS expressionAR .)
    COMMA           reduce using rule 34 (expressionAR -> MINUS expressionAR .)

  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 55 ]
  ! TIMES           [ shift and go to state 56 ]
  ! DIVIDE          [ shift and go to state 57 ]


state 62

    (36) expressionAR -> LPAREN . expressionAR RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 62

    expressionAR                   shift and go to state 90

state 63

    (16) inst -> IF expressionBo LCURLBRACKET . list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> IF expressionBo LCURLBRACKET . list RCURLBRACKET
    (3) list -> . inst
    (4) list -> . inst list
    (13) inst -> . FOR expressionBo LCURLBRACKET list RCURLBRACKET
    (14) inst -> . FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (15) inst -> . assignment SEMICOLON
    (16) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET
    (24) inst -> . FMT POINT PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> . FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> . FMT POINT PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> . FMT POINT SCAN LPAREN RPAREN SEMICOLON
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT

    FOR             shift and go to state 14
    IF              shift and go to state 16
    FMT             shift and go to state 17
    ID              shift and go to state 18
    VAR             shift and go to state 19

    list                           shift and go to state 91
    inst                           shift and go to state 13
    assignment                     shift and go to state 15

state 64

    (24) inst -> FMT POINT PRINT . LPAREN listID RPAREN SEMICOLON
    (26) inst -> FMT POINT PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 92


state 65

    (25) inst -> FMT POINT SCAN . LPAREN IDlist RPAREN SEMICOLON
    (27) inst -> FMT POINT SCAN . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 93


state 66

    (5) assignment -> ID ASSIGN expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR
    (37) expressionBo -> expressionAR . MORE expressionAR
    (38) expressionBo -> expressionAR . LESS expressionAR
    (39) expressionBo -> expressionAR . MOREEQUAL expressionAR
    (40) expressionBo -> expressionAR . LESSEQUAL expressionAR
    (42) expressionBo -> expressionAR . NOTEQUAL expressionAR
    (44) expressionBo -> expressionAR . EQUALSTO expressionAR

    SEMICOLON       reduce using rule 5 (assignment -> ID ASSIGN expressionAR .)
    LCURLBRACKET    reduce using rule 5 (assignment -> ID ASSIGN expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57
    MORE            shift and go to state 48
    LESS            shift and go to state 49
    MOREEQUAL       shift and go to state 50
    LESSEQUAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUALSTO        shift and go to state 53


state 67

    (6) assignment -> ID ASSIGN expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    SEMICOLON       reduce using rule 6 (assignment -> ID ASSIGN expressionBo .)
    LCURLBRACKET    reduce using rule 6 (assignment -> ID ASSIGN expressionBo .)
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 68

    (36) expressionAR -> LPAREN . expressionAR RPAREN
    (50) expressionBo -> LPAREN . expressionBo RPAREN
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 68
    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27

    expressionAR                   shift and go to state 94
    expressionBo                   shift and go to state 59

state 69

    (7) assignment -> ID EQUALS expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR
    (37) expressionBo -> expressionAR . MORE expressionAR
    (38) expressionBo -> expressionAR . LESS expressionAR
    (39) expressionBo -> expressionAR . MOREEQUAL expressionAR
    (40) expressionBo -> expressionAR . LESSEQUAL expressionAR
    (42) expressionBo -> expressionAR . NOTEQUAL expressionAR
    (44) expressionBo -> expressionAR . EQUALSTO expressionAR

    SEMICOLON       reduce using rule 7 (assignment -> ID EQUALS expressionAR .)
    LCURLBRACKET    reduce using rule 7 (assignment -> ID EQUALS expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57
    MORE            shift and go to state 48
    LESS            shift and go to state 49
    MOREEQUAL       shift and go to state 50
    LESSEQUAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUALSTO        shift and go to state 53


state 70

    (8) assignment -> ID EQUALS expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    SEMICOLON       reduce using rule 8 (assignment -> ID EQUALS expressionBo .)
    LCURLBRACKET    reduce using rule 8 (assignment -> ID EQUALS expressionBo .)
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 71

    (9) assignment -> VAR ID EQUALS . expressionAR
    (10) assignment -> VAR ID EQUALS . expressionBo
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 68
    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27

    expressionAR                   shift and go to state 95
    expressionBo                   shift and go to state 96

state 72

    (13) inst -> FOR expressionBo LCURLBRACKET list . RCURLBRACKET

    RCURLBRACKET    shift and go to state 97


state 73

    (41) expressionBo -> expressionBo NOTEQUAL expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    LCURLBRACKET    reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .)
    NOTEQUAL        reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .)
    EQUALSTO        reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .)
    RPAREN          reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .)
    SEMICOLON       reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .)
    COMMA           reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .)
    AND             shift and go to state 45
    OR              shift and go to state 46

  ! AND             [ reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .) ]
  ! OR              [ reduce using rule 41 (expressionBo -> expressionBo NOTEQUAL expressionBo .) ]
  ! NOTEQUAL        [ shift and go to state 43 ]
  ! EQUALSTO        [ shift and go to state 44 ]


state 74

    (43) expressionBo -> expressionBo EQUALSTO expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    LCURLBRACKET    reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .)
    NOTEQUAL        reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .)
    EQUALSTO        reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .)
    RPAREN          reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .)
    SEMICOLON       reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .)
    COMMA           reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .)
    AND             shift and go to state 45
    OR              shift and go to state 46

  ! AND             [ reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .) ]
  ! OR              [ reduce using rule 43 (expressionBo -> expressionBo EQUALSTO expressionBo .) ]
  ! NOTEQUAL        [ shift and go to state 43 ]
  ! EQUALSTO        [ shift and go to state 44 ]


state 75

    (45) expressionBo -> expressionBo AND expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    LCURLBRACKET    reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)
    NOTEQUAL        reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)
    EQUALSTO        reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)
    AND             reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)
    OR              reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)
    RPAREN          reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)
    SEMICOLON       reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)
    COMMA           reduce using rule 45 (expressionBo -> expressionBo AND expressionBo .)

  ! NOTEQUAL        [ shift and go to state 43 ]
  ! EQUALSTO        [ shift and go to state 44 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]


state 76

    (46) expressionBo -> expressionBo OR expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    LCURLBRACKET    reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)
    NOTEQUAL        reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)
    EQUALSTO        reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)
    AND             reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)
    OR              reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)
    RPAREN          reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)
    SEMICOLON       reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)
    COMMA           reduce using rule 46 (expressionBo -> expressionBo OR expressionBo .)

  ! NOTEQUAL        [ shift and go to state 43 ]
  ! EQUALSTO        [ shift and go to state 44 ]
  ! AND             [ shift and go to state 45 ]
  ! OR              [ shift and go to state 46 ]


state 77

    (14) inst -> FOR assignment SEMICOLON expressionBo . SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    SEMICOLON       shift and go to state 98
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 78

    (37) expressionBo -> expressionAR MORE expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    LCURLBRACKET    reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    NOTEQUAL        reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    EQUALSTO        reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    AND             reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    OR              reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    RPAREN          reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    SEMICOLON       reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    COMMA           reduce using rule 37 (expressionBo -> expressionAR MORE expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 79

    (38) expressionBo -> expressionAR LESS expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    LCURLBRACKET    reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    NOTEQUAL        reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    EQUALSTO        reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    AND             reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    OR              reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    RPAREN          reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    SEMICOLON       reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    COMMA           reduce using rule 38 (expressionBo -> expressionAR LESS expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 80

    (39) expressionBo -> expressionAR MOREEQUAL expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    LCURLBRACKET    reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    NOTEQUAL        reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    EQUALSTO        reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    AND             reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    OR              reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    RPAREN          reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    SEMICOLON       reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    COMMA           reduce using rule 39 (expressionBo -> expressionAR MOREEQUAL expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 81

    (40) expressionBo -> expressionAR LESSEQUAL expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    LCURLBRACKET    reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    NOTEQUAL        reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    EQUALSTO        reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    AND             reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    OR              reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    RPAREN          reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    SEMICOLON       reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    COMMA           reduce using rule 40 (expressionBo -> expressionAR LESSEQUAL expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 82

    (42) expressionBo -> expressionAR NOTEQUAL expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    LCURLBRACKET    reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    NOTEQUAL        reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    EQUALSTO        reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    AND             reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    OR              reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    RPAREN          reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    SEMICOLON       reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    COMMA           reduce using rule 42 (expressionBo -> expressionAR NOTEQUAL expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 83

    (44) expressionBo -> expressionAR EQUALSTO expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    LCURLBRACKET    reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    NOTEQUAL        reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    EQUALSTO        reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    AND             reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    OR              reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    RPAREN          reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    SEMICOLON       reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    COMMA           reduce using rule 44 (expressionBo -> expressionAR EQUALSTO expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 84

    (28) expressionAR -> expressionAR PLUS expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    MORE            reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    LESS            reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    MOREEQUAL       reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    LESSEQUAL       reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    NOTEQUAL        reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    EQUALSTO        reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    PLUS            reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    MINUS           reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    RPAREN          reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    SEMICOLON       reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    LCURLBRACKET    reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    AND             reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    OR              reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    COMMA           reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .)
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57

  ! TIMES           [ reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .) ]
  ! DIVIDE          [ reduce using rule 28 (expressionAR -> expressionAR PLUS expressionAR .) ]
  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 55 ]


state 85

    (29) expressionAR -> expressionAR MINUS expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    MORE            reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    LESS            reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    MOREEQUAL       reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    LESSEQUAL       reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    NOTEQUAL        reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    EQUALSTO        reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    PLUS            reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    MINUS           reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    RPAREN          reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    SEMICOLON       reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    LCURLBRACKET    reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    AND             reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    OR              reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    COMMA           reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .)
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57

  ! TIMES           [ reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .) ]
  ! DIVIDE          [ reduce using rule 29 (expressionAR -> expressionAR MINUS expressionAR .) ]
  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 55 ]


state 86

    (30) expressionAR -> expressionAR TIMES expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    MORE            reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    LESS            reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    MOREEQUAL       reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    LESSEQUAL       reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    NOTEQUAL        reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    EQUALSTO        reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    PLUS            reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    MINUS           reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    TIMES           reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    DIVIDE          reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    RPAREN          reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    SEMICOLON       reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    LCURLBRACKET    reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    AND             reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    OR              reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)
    COMMA           reduce using rule 30 (expressionAR -> expressionAR TIMES expressionAR .)

  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 55 ]
  ! TIMES           [ shift and go to state 56 ]
  ! DIVIDE          [ shift and go to state 57 ]


state 87

    (31) expressionAR -> expressionAR DIVIDE expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    MORE            reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    LESS            reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    MOREEQUAL       reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    LESSEQUAL       reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    NOTEQUAL        reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    EQUALSTO        reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    PLUS            reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    MINUS           reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    TIMES           reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    DIVIDE          reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    RPAREN          reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    SEMICOLON       reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    LCURLBRACKET    reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    AND             reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    OR              reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)
    COMMA           reduce using rule 31 (expressionAR -> expressionAR DIVIDE expressionAR .)

  ! PLUS            [ shift and go to state 54 ]
  ! MINUS           [ shift and go to state 55 ]
  ! TIMES           [ shift and go to state 56 ]
  ! DIVIDE          [ shift and go to state 57 ]


state 88

    (50) expressionBo -> LPAREN expressionBo RPAREN .

    LCURLBRACKET    reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)
    NOTEQUAL        reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)
    EQUALSTO        reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)
    AND             reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)
    OR              reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)
    RPAREN          reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)
    SEMICOLON       reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)
    COMMA           reduce using rule 50 (expressionBo -> LPAREN expressionBo RPAREN .)


state 89

    (36) expressionAR -> LPAREN expressionAR RPAREN .

    MORE            reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    LESS            reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    MOREEQUAL       reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    LESSEQUAL       reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    NOTEQUAL        reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    EQUALSTO        reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    PLUS            reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    MINUS           reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    TIMES           reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    DIVIDE          reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    RPAREN          reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    SEMICOLON       reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    LCURLBRACKET    reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    AND             reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    OR              reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)
    COMMA           reduce using rule 36 (expressionAR -> LPAREN expressionAR RPAREN .)


state 90

    (36) expressionAR -> LPAREN expressionAR . RPAREN
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR

    RPAREN          shift and go to state 89
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57


state 91

    (16) inst -> IF expressionBo LCURLBRACKET list . RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> IF expressionBo LCURLBRACKET list . RCURLBRACKET

    RCURLBRACKET    shift and go to state 99


state 92

    (24) inst -> FMT POINT PRINT LPAREN . listID RPAREN SEMICOLON
    (26) inst -> FMT POINT PRINT LPAREN . RPAREN SEMICOLON
    (18) listID -> . expressionAR
    (19) listID -> . expressionBo
    (20) listID -> . expressionBo COMMA listID
    (21) listID -> . expressionAR COMMA listID
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN

    RPAREN          shift and go to state 101
    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 68
    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27

    listID                         shift and go to state 100
    expressionAR                   shift and go to state 102
    expressionBo                   shift and go to state 103

state 93

    (25) inst -> FMT POINT SCAN LPAREN . IDlist RPAREN SEMICOLON
    (27) inst -> FMT POINT SCAN LPAREN . RPAREN SEMICOLON
    (22) IDlist -> . ID
    (23) IDlist -> . ID COMMA IDlist

    RPAREN          shift and go to state 105
    ID              shift and go to state 106

    IDlist                         shift and go to state 104

state 94

    (36) expressionAR -> LPAREN expressionAR . RPAREN
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR
    (37) expressionBo -> expressionAR . MORE expressionAR
    (38) expressionBo -> expressionAR . LESS expressionAR
    (39) expressionBo -> expressionAR . MOREEQUAL expressionAR
    (40) expressionBo -> expressionAR . LESSEQUAL expressionAR
    (42) expressionBo -> expressionAR . NOTEQUAL expressionAR
    (44) expressionBo -> expressionAR . EQUALSTO expressionAR

    RPAREN          shift and go to state 89
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57
    MORE            shift and go to state 48
    LESS            shift and go to state 49
    MOREEQUAL       shift and go to state 50
    LESSEQUAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUALSTO        shift and go to state 53


state 95

    (9) assignment -> VAR ID EQUALS expressionAR .
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR
    (37) expressionBo -> expressionAR . MORE expressionAR
    (38) expressionBo -> expressionAR . LESS expressionAR
    (39) expressionBo -> expressionAR . MOREEQUAL expressionAR
    (40) expressionBo -> expressionAR . LESSEQUAL expressionAR
    (42) expressionBo -> expressionAR . NOTEQUAL expressionAR
    (44) expressionBo -> expressionAR . EQUALSTO expressionAR

    SEMICOLON       reduce using rule 9 (assignment -> VAR ID EQUALS expressionAR .)
    LCURLBRACKET    reduce using rule 9 (assignment -> VAR ID EQUALS expressionAR .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57
    MORE            shift and go to state 48
    LESS            shift and go to state 49
    MOREEQUAL       shift and go to state 50
    LESSEQUAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUALSTO        shift and go to state 53


state 96

    (10) assignment -> VAR ID EQUALS expressionBo .
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    SEMICOLON       reduce using rule 10 (assignment -> VAR ID EQUALS expressionBo .)
    LCURLBRACKET    reduce using rule 10 (assignment -> VAR ID EQUALS expressionBo .)
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 97

    (13) inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET .

    FOR             reduce using rule 13 (inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET .)
    IF              reduce using rule 13 (inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET .)
    FMT             reduce using rule 13 (inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET .)
    ID              reduce using rule 13 (inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET .)
    VAR             reduce using rule 13 (inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET .)
    RCURLBRACKET    reduce using rule 13 (inst -> FOR expressionBo LCURLBRACKET list RCURLBRACKET .)


state 98

    (14) inst -> FOR assignment SEMICOLON expressionBo SEMICOLON . assignment LCURLBRACKET list RCURLBRACKET
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT

    ID              shift and go to state 18
    VAR             shift and go to state 19

    assignment                     shift and go to state 107

state 99

    (16) inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET . ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET .

    ELSE            shift and go to state 108
    FOR             reduce using rule 17 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET .)
    IF              reduce using rule 17 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET .)
    FMT             reduce using rule 17 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET .)
    ID              reduce using rule 17 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET .)
    VAR             reduce using rule 17 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET .)
    RCURLBRACKET    reduce using rule 17 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET .)


state 100

    (24) inst -> FMT POINT PRINT LPAREN listID . RPAREN SEMICOLON

    RPAREN          shift and go to state 109


state 101

    (26) inst -> FMT POINT PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 110


state 102

    (18) listID -> expressionAR .
    (21) listID -> expressionAR . COMMA listID
    (28) expressionAR -> expressionAR . PLUS expressionAR
    (29) expressionAR -> expressionAR . MINUS expressionAR
    (30) expressionAR -> expressionAR . TIMES expressionAR
    (31) expressionAR -> expressionAR . DIVIDE expressionAR
    (37) expressionBo -> expressionAR . MORE expressionAR
    (38) expressionBo -> expressionAR . LESS expressionAR
    (39) expressionBo -> expressionAR . MOREEQUAL expressionAR
    (40) expressionBo -> expressionAR . LESSEQUAL expressionAR
    (42) expressionBo -> expressionAR . NOTEQUAL expressionAR
    (44) expressionBo -> expressionAR . EQUALSTO expressionAR

    RPAREN          reduce using rule 18 (listID -> expressionAR .)
    COMMA           shift and go to state 111
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    TIMES           shift and go to state 56
    DIVIDE          shift and go to state 57
    MORE            shift and go to state 48
    LESS            shift and go to state 49
    MOREEQUAL       shift and go to state 50
    LESSEQUAL       shift and go to state 51
    NOTEQUAL        shift and go to state 52
    EQUALSTO        shift and go to state 53


state 103

    (19) listID -> expressionBo .
    (20) listID -> expressionBo . COMMA listID
    (41) expressionBo -> expressionBo . NOTEQUAL expressionBo
    (43) expressionBo -> expressionBo . EQUALSTO expressionBo
    (45) expressionBo -> expressionBo . AND expressionBo
    (46) expressionBo -> expressionBo . OR expressionBo

    RPAREN          reduce using rule 19 (listID -> expressionBo .)
    COMMA           shift and go to state 112
    NOTEQUAL        shift and go to state 43
    EQUALSTO        shift and go to state 44
    AND             shift and go to state 45
    OR              shift and go to state 46


state 104

    (25) inst -> FMT POINT SCAN LPAREN IDlist . RPAREN SEMICOLON

    RPAREN          shift and go to state 113


state 105

    (27) inst -> FMT POINT SCAN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 114


state 106

    (22) IDlist -> ID .
    (23) IDlist -> ID . COMMA IDlist

    RPAREN          reduce using rule 22 (IDlist -> ID .)
    COMMA           shift and go to state 115


state 107

    (14) inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment . LCURLBRACKET list RCURLBRACKET

    LCURLBRACKET    shift and go to state 116


state 108

    (16) inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE . LCURLBRACKET list RCURLBRACKET

    LCURLBRACKET    shift and go to state 117


state 109

    (24) inst -> FMT POINT PRINT LPAREN listID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 118


state 110

    (26) inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON .

    FOR             reduce using rule 26 (inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 26 (inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON .)
    FMT             reduce using rule 26 (inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 26 (inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 26 (inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON .)
    RCURLBRACKET    reduce using rule 26 (inst -> FMT POINT PRINT LPAREN RPAREN SEMICOLON .)


state 111

    (21) listID -> expressionAR COMMA . listID
    (18) listID -> . expressionAR
    (19) listID -> . expressionBo
    (20) listID -> . expressionBo COMMA listID
    (21) listID -> . expressionAR COMMA listID
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 68
    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27

    expressionAR                   shift and go to state 102
    listID                         shift and go to state 119
    expressionBo                   shift and go to state 103

state 112

    (20) listID -> expressionBo COMMA . listID
    (18) listID -> . expressionAR
    (19) listID -> . expressionBo
    (20) listID -> . expressionBo COMMA listID
    (21) listID -> . expressionAR COMMA listID
    (28) expressionAR -> . expressionAR PLUS expressionAR
    (29) expressionAR -> . expressionAR MINUS expressionAR
    (30) expressionAR -> . expressionAR TIMES expressionAR
    (31) expressionAR -> . expressionAR DIVIDE expressionAR
    (32) expressionAR -> . ID
    (33) expressionAR -> . INT
    (34) expressionAR -> . MINUS expressionAR
    (35) expressionAR -> . FLOAT
    (36) expressionAR -> . LPAREN expressionAR RPAREN
    (37) expressionBo -> . expressionAR MORE expressionAR
    (38) expressionBo -> . expressionAR LESS expressionAR
    (39) expressionBo -> . expressionAR MOREEQUAL expressionAR
    (40) expressionBo -> . expressionAR LESSEQUAL expressionAR
    (41) expressionBo -> . expressionBo NOTEQUAL expressionBo
    (42) expressionBo -> . expressionAR NOTEQUAL expressionAR
    (43) expressionBo -> . expressionBo EQUALSTO expressionBo
    (44) expressionBo -> . expressionAR EQUALSTO expressionAR
    (45) expressionBo -> . expressionBo AND expressionBo
    (46) expressionBo -> . expressionBo OR expressionBo
    (47) expressionBo -> . NOT expressionBo
    (48) expressionBo -> . TRUE
    (49) expressionBo -> . FALSE
    (50) expressionBo -> . LPAREN expressionBo RPAREN

    ID              shift and go to state 35
    INT             shift and go to state 31
    MINUS           shift and go to state 30
    FLOAT           shift and go to state 32
    LPAREN          shift and go to state 68
    NOT             shift and go to state 25
    TRUE            shift and go to state 26
    FALSE           shift and go to state 27

    expressionBo                   shift and go to state 103
    listID                         shift and go to state 120
    expressionAR                   shift and go to state 102

state 113

    (25) inst -> FMT POINT SCAN LPAREN IDlist RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 121


state 114

    (27) inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON .

    FOR             reduce using rule 27 (inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 27 (inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON .)
    FMT             reduce using rule 27 (inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 27 (inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 27 (inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON .)
    RCURLBRACKET    reduce using rule 27 (inst -> FMT POINT SCAN LPAREN RPAREN SEMICOLON .)


state 115

    (23) IDlist -> ID COMMA . IDlist
    (22) IDlist -> . ID
    (23) IDlist -> . ID COMMA IDlist

    ID              shift and go to state 106

    IDlist                         shift and go to state 122

state 116

    (14) inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET . list RCURLBRACKET
    (3) list -> . inst
    (4) list -> . inst list
    (13) inst -> . FOR expressionBo LCURLBRACKET list RCURLBRACKET
    (14) inst -> . FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (15) inst -> . assignment SEMICOLON
    (16) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET
    (24) inst -> . FMT POINT PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> . FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> . FMT POINT PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> . FMT POINT SCAN LPAREN RPAREN SEMICOLON
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT

    FOR             shift and go to state 14
    IF              shift and go to state 16
    FMT             shift and go to state 17
    ID              shift and go to state 18
    VAR             shift and go to state 19

    assignment                     shift and go to state 15
    list                           shift and go to state 123
    inst                           shift and go to state 13

state 117

    (16) inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET . list RCURLBRACKET
    (3) list -> . inst
    (4) list -> . inst list
    (13) inst -> . FOR expressionBo LCURLBRACKET list RCURLBRACKET
    (14) inst -> . FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET
    (15) inst -> . assignment SEMICOLON
    (16) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET
    (17) inst -> . IF expressionBo LCURLBRACKET list RCURLBRACKET
    (24) inst -> . FMT POINT PRINT LPAREN listID RPAREN SEMICOLON
    (25) inst -> . FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON
    (26) inst -> . FMT POINT PRINT LPAREN RPAREN SEMICOLON
    (27) inst -> . FMT POINT SCAN LPAREN RPAREN SEMICOLON
    (5) assignment -> . ID ASSIGN expressionAR
    (6) assignment -> . ID ASSIGN expressionBo
    (7) assignment -> . ID EQUALS expressionAR
    (8) assignment -> . ID EQUALS expressionBo
    (9) assignment -> . VAR ID EQUALS expressionAR
    (10) assignment -> . VAR ID EQUALS expressionBo
    (11) assignment -> . ID INCREMENT
    (12) assignment -> . ID DECREMENT

    FOR             shift and go to state 14
    IF              shift and go to state 16
    FMT             shift and go to state 17
    ID              shift and go to state 18
    VAR             shift and go to state 19

    list                           shift and go to state 124
    inst                           shift and go to state 13
    assignment                     shift and go to state 15

state 118

    (24) inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON .

    FOR             reduce using rule 24 (inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON .)
    IF              reduce using rule 24 (inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON .)
    FMT             reduce using rule 24 (inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON .)
    ID              reduce using rule 24 (inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON .)
    VAR             reduce using rule 24 (inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON .)
    RCURLBRACKET    reduce using rule 24 (inst -> FMT POINT PRINT LPAREN listID RPAREN SEMICOLON .)


state 119

    (21) listID -> expressionAR COMMA listID .

    RPAREN          reduce using rule 21 (listID -> expressionAR COMMA listID .)


state 120

    (20) listID -> expressionBo COMMA listID .

    RPAREN          reduce using rule 20 (listID -> expressionBo COMMA listID .)


state 121

    (25) inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON .

    FOR             reduce using rule 25 (inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON .)
    IF              reduce using rule 25 (inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON .)
    FMT             reduce using rule 25 (inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON .)
    ID              reduce using rule 25 (inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON .)
    VAR             reduce using rule 25 (inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON .)
    RCURLBRACKET    reduce using rule 25 (inst -> FMT POINT SCAN LPAREN IDlist RPAREN SEMICOLON .)


state 122

    (23) IDlist -> ID COMMA IDlist .

    RPAREN          reduce using rule 23 (IDlist -> ID COMMA IDlist .)


state 123

    (14) inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list . RCURLBRACKET

    RCURLBRACKET    shift and go to state 125


state 124

    (16) inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list . RCURLBRACKET

    RCURLBRACKET    shift and go to state 126


state 125

    (14) inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET .

    FOR             reduce using rule 14 (inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET .)
    IF              reduce using rule 14 (inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET .)
    FMT             reduce using rule 14 (inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET .)
    ID              reduce using rule 14 (inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET .)
    VAR             reduce using rule 14 (inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET .)
    RCURLBRACKET    reduce using rule 14 (inst -> FOR assignment SEMICOLON expressionBo SEMICOLON assignment LCURLBRACKET list RCURLBRACKET .)


state 126

    (16) inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET .

    FOR             reduce using rule 16 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET .)
    IF              reduce using rule 16 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET .)
    FMT             reduce using rule 16 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET .)
    ID              reduce using rule 16 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET .)
    VAR             reduce using rule 16 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET .)
    RCURLBRACKET    reduce using rule 16 (inst -> IF expressionBo LCURLBRACKET list RCURLBRACKET ELSE LCURLBRACKET list RCURLBRACKET .)

